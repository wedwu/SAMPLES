<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title></title>
  <style>
    body {
      display: flex;
      justify-content: center;
      height: 100vh;
      margin: 0;
      background: #29282e;
      font-family: sans-serif;
      color: white;
    }

    h2, h3, p { margin: 0; padding: 0; }

    p {
      white-space: pre-line;
      font-size: 13px;
    }

    canvas {
      border: 1px solid #29282e;
      position: absolute;
      left: 0;
      top: 0;
      z-index: 1;
    }

    #container {
      position: relative;
      width: 1400px;
      height: auto;
      display: block;
    }

    .dynamic-box {
      position: absolute;
      background: #1e1d22;
      padding: 8px;
      color: white;
      font-size: 14px;
      border-radius: 5px;
      box-sizing: border-box;
      overflow: hidden;
    }
  </style>
</head>

<body>
  <div id="container">
    <canvas id="diagram"></canvas>
  </div>

  <script>
    const config = {
      columns: [
        {
          color: '#29282e',
          boxes: [
            { id: 'server01', status: 'up' },
            { id: 'server02', status: 'up' },
            { id: 'server03', status: 'up' },
          ]
        },
        {
          color: '#29282e',
          boxes: [
            { id: 'server11', status: 'up' },
            { id: 'server12', status: 'down' },
            { id: 'server13', status: 'down' },
            { id: 'server14', status: 'down' },
            { id: 'server15', status: 'up' },
            { id: 'server16', status: 'up' }
          ]
        },
        {
          color: '#29282e',
          boxes: [
            { id: 'server21', status: 'up' },
            { id: 'server22', status: 'up' }
          ]
        }
      ],

      connections: [
        { from: 'server01', to: 'server11', color: '#4c5e74' },
        { from: 'server01', to: 'server12', color: '#ff5242' },
        { from: 'server01', to: 'server13', color: '#ff5242' },
        { from: 'server01', to: 'server14', color: '#ff5242' },

        { from: 'server02', to: 'server15', color: '#ff5242' },

        { from: 'server11', to: 'server21', color: '#4c5e74' },
        { from: 'server11', to: 'server22', color: '#4c5e74' },
        { from: 'server12', to: 'server22', color: '#ff5242' },
        { from: 'server13', to: 'server22', color: '#ff5242' },
      ],

      boxMargin: 12,
      baseBoxHeight: 150,
      lineSpacing: 40
    };

    const maxBoxes = Math.max(...config.columns.map(col => col.boxes.length));
    const canvas = document.getElementById('diagram');
    const ctx = canvas.getContext('2d');

    canvas.width = 1400;
    canvas.height = maxBoxes * (config.baseBoxHeight + config.boxMargin * 2);

    const width = canvas.width;
    const height = canvas.height;
    const colWidth = width / config.columns.length;

    const boxMap = {};

    /* -----------------------------------------------------
       LAYOUT COLUMNS + CREATE DIVs IN EXACT CANVAS POSITIONS
    ------------------------------------------------------*/
    layoutColumns = () => {
      const container = document.getElementById('container');
      container.style.height = height + 'px';

      for (let colIndex = 0; colIndex < config.columns.length; colIndex++) {
        const column = config.columns[colIndex];
        const boxes = column.boxes;

        const boxHeight = height / maxBoxes;

        boxes.forEach((box, i) => {
          const x = colWidth * colIndex + config.boxMargin;
          let y;

          if (colIndex === 0) {
            if (i === 0) {
              y = config.boxMargin;
            } else {
              const indexFromBottom = boxes.length - i;
              const bottomStart = height - boxHeight + config.boxMargin;
              y = bottomStart - (indexFromBottom - 1) * boxHeight;
            }
          } else {
            y = i * boxHeight + config.boxMargin;
          }

          const w = (colWidth - config.boxMargin * 2) * 0.70;
          const h = boxHeight - config.boxMargin * 2;

          boxMap[box.id] = { x, y, w, h, status: box.status, colIndex };

          /* ----- CREATE PERFECTLY ALIGNED DIV ----- */
          const div = document.createElement('div');
          div.className = 'dynamic-box';
          div.id = `box-${box.id}`;
          div.style.left = x + 'px';
          div.style.top = y + 'px';
          div.style.width = w + 'px';
          div.style.height = h + 'px';
          div.style.border = `4px solid ${box.status === 'down' ? '#ff5242' : '#4c5e74'}`;
          div.style.zIndex = 10;

          const title = document.createElement('h3');
          title.textContent = box.id;

          const details = document.createElement('p');
          details.textContent = `Status: ${box.status}
Column: ${colIndex + 1}
Index: ${i}`;

          div.appendChild(title);
          div.appendChild(details);
          container.appendChild(div);
        });
      }
    };

    /* ------------------ DRAW LINES ---------------------*/
    drawLines = () => {
      ctx.lineWidth = 2;
      const maxLaneWidth = colWidth * 0.25;

      const sourceGroups = {};
      config.connections.forEach(conn => (sourceGroups[conn.from] ||= []).push(conn));

      Object.values(sourceGroups).forEach(conns => {
        const count = conns.length;
        conns.forEach((conn, idx) => {
          const rev = count - idx;
          conn._sourceCount = count;
          conn._sourceIndex = idx;
          conn._sourceLane = (rev / (count + 1)) * (maxLaneWidth / config.lineSpacing);
        });
      });

      const targetGroups = {};
      config.connections.forEach(conn => (targetGroups[conn.to] ||= []).push(conn));

      Object.values(targetGroups).forEach(conns => {
        const count = conns.length;
        conns.forEach((conn, idx) => {
          const rev = count - idx;
          conn._targetCount = count;
          conn._targetIndex = idx;
          conn._targetLane = (rev / (count + 1)) * (maxLaneWidth / config.lineSpacing);
        });
      });

      config.connections.forEach(conn => {
        const startBox = boxMap[conn.from];
        const endBox = boxMap[conn.to];

        if (!startBox || !endBox) return;

        const startCol = startBox.colIndex;
        const endCol = endBox.colIndex;
        const count = conn._sourceCount || 1;
        const idx = conn._sourceIndex || 0;

        const start = {
          x: startBox.x + startBox.w,
          y: startBox.y + (startBox.h / (count + 1)) * (idx + 1)
        };

        let endY = endBox.y + endBox.h / 2;
        if (conn._targetCount > 1) {
          const spacing = endBox.h / (conn._targetCount + 1);
          endY = endBox.y + spacing * (conn._targetIndex + 1);
        }

        const end = { x: endBox.x, y: endY };
        let midX;

        if (startCol === 0 && endCol === 1) {
          midX = start.x + config.lineSpacing * conn._sourceLane;
        } else if (startCol === 1 && endCol === 2) {
          midX = end.x - config.lineSpacing * conn._targetLane;
        } else {
          const dir = endCol > startCol ? 1 : -1;
          midX = start.x + dir * config.lineSpacing * (conn._sourceLane || 1);
        }

        ctx.strokeStyle = conn.color || '#000';
        ctx.beginPath();
        ctx.moveTo(start.x, start.y);
        ctx.lineTo(midX, start.y);
        ctx.lineTo(midX, end.y);
        ctx.lineTo(end.x, end.y);
        ctx.stroke();
      });
    };

    /* ------------------- DRAW BOX BORDERS ------------------*/
    drawBoxesOnTop = () => {
      Object.values(boxMap).forEach(({ x, y, w, h, status }) => {
        ctx.lineWidth = 10;
        ctx.strokeStyle = status === 'down' ? '#ff5242' : '#4c5e74';
        ctx.strokeRect(x, y, w, h);
      });
    };

    /* ------------------- EXECUTE ---------------------------*/
    layoutColumns();
    drawLines();
    drawBoxesOnTop();
  </script>
</body>
</html>
